# 考察メモ

## 9/17

### 状態

```rust
struct State {
    grid: Vec<Vec<Option<Point>>>,
    points: Vec<Point>,
    edges: Vec<Vec<Vec<bool>>>,
}
```

### 点が持つ情報

```rust
struct Pos {
    x: i64,
    y: i64,
}

struct Point {
    // 追加された点かどうか
    is_added: bool,
    // 各方向にある最も近い点
    // 方向を0~7の値に決める
    nearest_points: Vec<Option<Point>>,
    // その点を使って作った点
    used_points: Vec<Point>,
    // 各方向が長方形の辺に使われているか
    used_dir: Vec<bool>,
}
```

### 近傍

- 3点選んで四角を作る
    - ランダムに1点選んで、90度（上と左、左下と左上）の方向に点があれば、新しい点を作る
- 四角を付け替える
```
ooo
xox
```

### 考察

- 1点選んで、90度（上と左、左下と左上）の方向に点があれば、新しい点を作れる
    - 1番近い点しかだめ
    - 新しい点と繋ごうとしている点の間に点があってもダメ
- なるべく遠いところに点を作りたい
    - 斜めが必要
        - でも斜めだけだと伸ばせない
    - 斜めと垂直はある程度区別して扱う必要がありそう
- ある点を消す時には、その点を使った長方形によってできた点はロールバックしなければいけない
    - 作った点を、材料の点は覚えておく
        - 再帰的に消す必要がある
- 1つの点は最大4つの四角に使える
    - 垂直2、斜め2
- 正方形を作ると、対角線を斜め四角の辺として使える
    - 評価高めにする?

## 9/18

- 四角を削除する処理を追加
- 再帰的に削除しているけど
    - 処理順が保証されていない
        - 最後にトポロジカルソートし直す
            - だけじゃ駄目かも
            - 辺上に点が作られた場合に順序を保証する必要がある
        - idを振ることで解決
    - 再帰しすぎる
        - recursion_limitを設ける
- O(n)の処理はBinaryHeapと置き換えてみる
    - それか、bufferみたいにオンオフだけ切り替える

## 9/19

- 時間伸ばしても（10s）スコアはほとんど伸びない
    - 近傍を工夫したい
    - 遠いところに点が作れるようになりたい
- 一気に遠いところに作るのではなく、ちょっとずつ伸ばすのが良い
    - ある程度人為的にやる必要がありそう
    - それかいい感じのスコア関数を作るか
    - あくまで仮説、違う可能性を一応考えておく
- 斜めと垂直が独立に見えるけど、そうではない
    - 偶奇が大事
    - 一つずれると作れなくなる
- 目標を決めて、その状態になりやすい近傍を考える
- 点同士の依存関係、割と大きい木になっているっぽい
    - 最初が大事?
    - でかい斜めは作らない方がいい?
- 伸ばさない方向に斜めを重ねちゃうと、伸ばしたい方に伸びなくなる
- 真ん中は疎でもいい
- 角は進出できる
    - でも難しい、孤立点になりそう

### TODO

- 近傍の採用率を計測する
- スコアの遷移の可視化
- 焼きなまし過程を可視化する（優先度低め）
    - ビジュアライザを使う

### 高速化

- O(n)の解消
- recursion_limitを設ける
    - 消す前に、繋がっている点の数を求める
- 不要な`Pos.clone()`を消す

### 近傍

- 付け替える
    - この位置関係になっているxを探す
    ```
       o

    o  x   o
    ```
    - 結果: スコア下がる
        - 試行回数が下がってる
        - 時間長くしても（30s）、単純に消す方に負けてる
    - 原因探す、改善
- 既にある辺の途中に点を作る
    - 難しい
- 連鎖的に四角を作る
    - 二つの点から作る
        - 理想の位置の点が作れるか、連鎖的に
- dfsっぽく伸ばす
- 消して作る
    - 辺を共有することを許す
    - 後で壊す

- 点の選び方を工夫する

### スコア計算

- 四角が作りやすくなると評価
- なるべく小さい四角が良い
    - 疎な盤面だと小さい四角は作りづらい
- 現状`Command::Add`が無条件に採用なので、何か一つスコア項を加える

## 9/20

- ちょっとずつ伸ばすのは点がないと難しい
    - 割と焼きなましで作れている
- N、Mによって全然課題が違う
    - (M / N*N)で分けた方がいいかも
- 同じケースでも点数のブレが割とある
    - 同じケースでうまくいってる時とない時を観察する
    - 0042.txt
        - うまくいってる時は塊ができている
    - 0020.txt
        - 遠くに点を作っている

### 高速化

- O(n)の解消
    - そんなに変わらなかった
- recursion_limitを設ける
    - 消す前に、繋がっている点の数を求める
    - recursion_limitは後で調整

### スコア計算

```
total: 107209644
(1742236, '0098')
(1598767, '0038')
(1586661, '0092')
(1469426, '0013')
(1442859, '0048')
(1432605, '0063')
(1371600, '0042')
(1371248, '0065')
(1361530, '0016')
(1353586, '0022')
(690380, '0000')
(796408, '0017')
(797280, '0062')
(813683, '0028')
(817548, '0079')
(820274, '0002')
(835806, '0018')
(842112, '0051')
(842864, '0020')
(847332, '0060')
ave: 1072096.44
 500000 ~  549999:
 550000 ~  599999:
 600000 ~  649999:
 650000 ~  699999: o
 700000 ~  749999:
 750000 ~  799999: oo
 800000 ~  849999: ooooooo
 850000 ~  899999: oooo
 900000 ~  949999: oooooooooooo
 950000 ~  999999: oooooooooooooooooo
1000000 ~ 1049999: ooooooooooooo
1050000 ~ 1099999: oooooooo
1100000 ~ 1149999: ooooooo
1150000 ~ 1199999: oooooo
1200000 ~ 1249999: ooooo
1250000 ~ 1299999: oo
1300000 ~ 1349999: ooooo
1350000 ~ 1399999: oooo
1400000 ~ 1449999: oo
1450000 ~ 1499999: o
1500000 ~ 1549999:
1550000 ~ 1599999: oo
1600000 ~ 1649999:
1650000 ~ 1699999:
1700000 ~ 1749999: o
1750000 ~ 1799999:
1800000 ~ 1849999:
1850000 ~ 1899999:
1900000 ~ 1949999:
1950000 ~ 1999999:
```
